# Изброен тип

## 1. Основна идея

В практиката често имаме променлива, която може да приема **ограничен, краен набор от логически стойности**.

Например:

- **Състояние на файл:** `Open`, `Closed`
- **Тип потребител:** `Admin`, `User`, `Guest`
- **Състояние на връзка:** `Connected`, `Disconnected`, `Pending`

Най-простата (но лоша) реализация е чрез `int`:

```cpp
// 0 - open, 1 - closed, 2 - pending
int state = 0;
```

Тук променливата `state` е от тип `int`.

Типът `int` означава променлива, която може да съдържа *произволна стойност от интервала на представимите цели числа*.

Това е фундаментално различно от променлива, която може да приема само *три конкретни логически стойности*.

### Нямаме гаранция за валидност

Компилаторът знае единствено, че `state` е `int`.

Следователно това е напълно допустимо:

```cpp
// Компилира се
state = 42;

// Компилира се
state = -7;

// Компилира се
state = 100000;
```

Компилаторът няма механизъм да ограничи допустимите стойности до `{ 0, 1, 2 }`, защото типът `int` не носи такава информация.

С други думи:

- Логическото ограничение съществува само в главата на програмиста
- Типовата система не го знае
- Следователно не може да го провери

### Липсва семантика

Когато имаме:

```cpp
int state = 1;
```

От самия код не може да се разбере:

- Какво означава 1
- Част от кой набор стойности е
- Валидна ли е тази стойност

Числото няма самодокументиращ се смисъл.

За сравнение:

```cpp
Status state = Status::Closed;
```

Тук семантиката е част от типа и от самата стойност.

### Липса на типова изолация

Да разгледаме два независими логически набора:

```cpp
// 0 - open, 1 - closed
int file_state = 1;

// 0 - disconnected, 1 - connected
int connection_state = 1;
```

И двете са `int`. Компилаторът не прави разлика между тях.

Това е допустимо:

```cpp
if (file_state == connection_state) { ... }
```

Логически това може да няма никакъв смисъл, но типовата система не може да го забрани.

### Формално казано

Когато използваме `int`:

- Моделираме ограничено множество чрез неограничен тип
- Ограничението съществува само на ниво договор, не на ниво типова система
- Няма компилаторна проверка за коректност

## 2. Класически `enum`

Изброеният тип представлява **краен набор от именувани константи**.

```cpp
enum Status {
    Open,
    Closed,
    Pending
};
```

Това дефинира:

- **Нов тип:** `Status`
- **Три възможни стойности:** `Open`, `Closed`, `Pending`

```cpp
Status s = Open;
```

Когато използваме `enum`:

- Създаваме нов тип
- Типът дефинира допустимия набор от стойности
- Компилаторът може да наложи ограничения

### Какво представлява `enum` вътрешно?

Компилаторът представя изброения тип чрез цяло число. По подразбиране:

```cpp
Open    = 0
Closed  = 1
Pending = 2
```

Това означава:

```cpp
Status s = Open;
```

Вътрешно е еквивалентно на:

```cpp
int s = 0;
```

Но логически типът вече е `Status`, а не просто `int`.

Можем да зададем конкретни стойности:

```cpp
enum Status {
    OK = 200,
    NotFound = 404,
    ServerError = 500
};
```

## 3. Обхват

*Scope* означава областта от програмата, в която дадено име е валидно.

При класически `enum` имената на стойностите се поставят в същия обхват, в който е дефиниран типът.

```cpp
enum Error {
    OK,
    NotFound
};
```

След това можем да използваме:

```cpp
Error e = OK;
```

Името `OK` е директно достъпно.

### Проблем със scope

```cpp
enum Error {
    OK,
    NotFound
};

enum Result {
    OK,
    Failed
};
```

Това няма да компилира, защото `OK` вече съществува.

Класическият `enum` *замърсява* обхвата с имената си.

## 4. Проблеми на класическия `enum`

### Неявна конверсия към `int`

```cpp
Status s = Open;

// Позволено
int x = s;
```

Изброеният тип автоматично се преобразува към цяло число.

### Позволява невалидни стойности

```cpp
Status s = (Status)100;
```

Компилаторът ще го позволи (100 не е дефинирана стойност на `Status`, но езикът не ни защитава).

### Смесване на различни `enum`-и

```cpp
enum A { A1 };
enum B { B1 };

// Позволено
if (A1 == B1) { ... }
```

Логически безсмислено, но допустимо. Причината - и двата типа се разглеждат като цели числа.

## 5. `enum class` (C++11)

C++11 въвежда **типово безопасен изброен тип**:

```cpp
enum class Status {
    Open,
    Closed,
    Pending
};
```

### Няма инжектиране в обхвата

```cpp
Status s = Status::Open;
```

Стойностите принадлежат на типа.

### Няма неявна конверсия към `int`

```cpp
Status s = Status::Open;

// Грешка
int x = s;
```

Ако искаме числовата стойност:

```cpp
int x = static_cast<int>(s);
```

### Не могат да се сравняват различни `enum`-и

```cpp
enum class A { A1 };
enum class B { B1 };

// Грешка
if (A::A1 == B::B1) { ... }
```

Типова безопасност.

## 6. Избор на подлежащ тип

Всеки `enum` се представя вътрешно чрез целочислен тип.

По подразбиране това обикновено е `int`, но стандартът позволява компилаторът да избере друг достатъчно голям тип.

Можем изрично да го зададем:

```cpp
enum class Small : unsigned char {
    A,
    B,
    C
};
```

Тук:

```cpp
sizeof(Small) == 1
```

### Може ли класическият `enum` да има друг тип?

Да (от C++11 нататък):

```cpp
enum Color : unsigned char {
    Red,
    Green,
    Blue
};
```

## 7. Реална употреба

Да разгледаме пример с вход от потребител:

```cpp
#include <iostream>

enum class Role {
    Admin,
    User,
    Guest,
    Unknown
};
```

Функция за парсване:

```cpp
Role parse_role(int input) {
    if (input == 0) return Role::Admin;
    if (input == 1) return Role::User;
    if (input == 2) return Role::Guest;
    
    return Role::Unknown;
}
```

Използване:

```cpp
int input;
std::cin >> input;

Role r = parse_role(input);

if (r == Role::Admin) {
    std::cout << "Full access.\n";
}

// ...
```

Тук:

- Външният свят работи с числа
- Вътрешната логика работи със строго дефиниран тип
- Невалидни стойности не могат да се появят без изрично нарушение