# Структури

## 1. Основна идея

В програмирането често работим с обекти, които се описват чрез **няколко свързани стойности**.

Например:

- **Точка в равнината:** Две координати
- **Студент:** Име, факултетен номер, успех
- **Банкова сметка:** Номер, баланс, валута
- **Мрежов пакет:** Заглавна част, данни

Най-простият (но концептуално неправилен) начин е да използваме отделни променливи:

```cpp
char name[32] = "Ivan";
int faculty_number = 12345;
double grade = 5.75;
```

Проблемът тук е, че:

- Няма единен тип, който да описва "Студент"
- Данните не са групирани логически
- Могат лесно да се смесят с други несвързани променливи
- Не можем да ги предаваме като един обект

## 2. Съставен тип

За да моделираме логически обект с няколко компонента, дефинираме нов тип чрез `struct`.

```cpp
struct Student {
    char name[32];
    int faculty_number;
    double grade;
};
```

Тук:

- `Student` е нов тип
- Той съдържа три члена (*members*)
- Тези членове образуват едно цяло

### Използване

```cpp
Student s;
s.name = "Ivan";
s.faculty_number = 12345;
s.grade = 5.75;
```

Или с инициализация:

```cpp
Student s{ "Ivan", 12345, 5.75 };
```

## 3. Предимство на типовата система

Сега функцията може да бъде:

```cpp
void print_student(const Student& s);
```

Извикване:

```cpp
Student s{ "Ivan", 12345, 5.75 };

print_student(s);
```

Вече:

- Не можем да разменим аргументи
- Не можем да подадем произволни три стойности
- Типовата система знае какво е "Студент"

### Какво представлява `struct` формално?

`struct` дефинира съставен (*aggregate*) тип, който съдържа *последователност от членове с фиксирани типове*.

Всеки обект от този тип:

- Заема определен брой байтове
- Има фиксирано разположение в паметта
- Съдържа членовете си в определен ред

## 4. Разположение в паметта

Да разгледаме:

```cpp
struct Point {
    double x;
    double y;
};
```

Ако `double` е 8 байта:

```
Offset 0 → x (8 байта)
Offset 8 → y (8 байта)
```

Общ размер:

```cpp
sizeof(Point) == 16
```

Членовете се разполагат последователно в паметта.

### Alignment

Всеки тип има изискване за подравняване.

Примерно:

| Тип    | Размер | Подравняване |
| ------ | ------ | ------------ |
| char   | 1      | 1            |
| int    | 4      | 4            |
| double | 8      | 8            |

Компилаторът гарантира, че всеки член започва на адрес, кратен на неговия *alignment*.

### Padding

Да разгледаме:

```cpp
struct A {
    char c;
    int x;
};
```

Разположение:

```
Offset 0   → c (1 байт)
Offset 1-3 → padding
Offset 4   → x (4 байта)
```

Общ размер:

```cpp
sizeof(A) == 8
```

Причина:

- `int` изисква подравняване на 4 байта
- Компилаторът добавя *padding*

### Padding в края

```cpp
struct B {
    char c;
    int x;
    char d;
};
```

Възможно разположение:

```
0    → c
1-3  → padding
4-7  → x
8    → d
9-11 → padding
```

Размер:

```cpp
sizeof(B) == 12
```

Причина - целият обект трябва да е подравнен спрямо най-строгото изискване на членовете си.

### Оптимизация чрез пренареждане

```cpp
struct Bad {
    char c;
    double d;
    char e;
};
```

Възможен размер: 24 байта.

По-добре:

```cpp
struct Good {
    double d;
    char c;
    char e;
};
```

Размер: 16 байта. Редът на членовете влияе върху паметта.

## 5. Формално обобщение

`struct`:

- Дефинира нов съставен тип
- Групира логически свързани данни
- Позволява типова защита на композицията
- Има фиксиран memory layout (при standard-layout типове)
- Подлежи на alignment и padding

`struct` не е просто "контейнер за променливи".

Той:

- Създава нов тип
- Капсулира *инвариант* (логическо единство)
- Прави композицията част от типовата система

С други думи - ако `enum` моделира ограничен набор от стойности, `struct` моделира съставен обект с вътрешна структура.