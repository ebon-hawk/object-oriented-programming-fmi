# Изброен тип. Структури. Разположение в паметта. Битови полета

Използването на глобални променливи не е позволено.

### Задача 1 → Графични обекти

Да се реализира система за представяне на графични обекти.

Дефинирайте изброени типове:

- `Color` със стойности: `RED`, `GREEN`, `BLUE`, `WHITE`
- `ShapeType` със стойности: `POINT`, `LINE`, `RECTANGLE`

Дефинирайте структура `Style`, използваща битови полета:

- `color` → 3 бита
- `isVisible` → 1 бит
- `isFilled` → 1 бит
- `borderThickness` → 3 бита (стойности от 0 до 7)

Дефинирайте структура:

```cpp
struct GraphicObject {
    float x, y;
    ShapeType type;
    Style style;
};
```

От стандартния вход се въвежда цяло число `N`.

Да се задели динамичен масив с `N` елемента от тип `GraphicObject`.

Да се реализира функция, която инициализира обекта със случайни допустими стойности:

```cpp
void initObject(GraphicObject& obj);
```

Дефинирайте тип:

```cpp
typedef bool (*ObjectFilter)(const GraphicObject&);
```

Да се реализират следните предикати:

- `isRedAndVisible`
- `isHeavyBorder` (дебелина > 5)

Да се реализира функция, която извежда на екрана обектите, удовлетворяващи подадения предикат:

```cpp
void printFiltered(GraphicObject* arr, int size, ObjectFilter filter);
```

---

### Задача 2 → Симулация на мрежови пакети

Да се реализира симулация на обработка на мрежови пакети.

Дефинирайте структура `PacketHeader`, използваща битови полета:

- `id` → 8 бита
- `priority` → 4 бита (стойности 0-15)
- `protocol` → 4 бита

Дефинирайте `union`, който представя пакета по два начина:

```cpp
struct PacketHeader {
    unsigned id : 8;
    unsigned priority : 4;
    unsigned protocol : 4;
};

union Packet {
    PacketHeader header;
    unsigned short rawData;
};
```

От стандартния вход се въвежда цяло число `N`.

Да се задели динамичен масив с `N` елемента от тип `Packet`.

Да се реализира функция, която прилага подадена трансформация върху пакета:

```cpp
void processPacket(Packet& p, void (*transform)(Packet&));
```

Да се реализират следните трансформации:

- `boostPriority` → задава максимална стойност (15) на полето `priority` чрез достъп до битовите полета
- `maskId` → прилага побитова XOR операция върху `rawData` с константата `0xFF00`

Да се реализира масив от указатели към функции (трансформации).

Потребителят избира коя операция да бъде приложена върху всички елементи на масива.

---

### Задача 3 → Система за инвентар на RPG игра

Да се реализира система за управление на инвентар в RPG игра.

Дефинирайте изброен тип:

```cpp
enum ItemType { WEAPON, ARMOR, POTION };
```

Дефинирайте структура:

```cpp
struct Item {
    char name[32];
    ItemType type;
    int power;
    double weight;
};
```

От стандартния вход се въвежда цяло число `N`.

Да се задели динамичен масив с `N` елемента от тип `Item`. Потребителят въвежда данните за всеки предмет.

Дефинирайте тип:

```cpp
typedef int (*ItemComparator)(const Item&, const Item&);
```

Да се реализират следните функции:

- `compareByPower` → връща разликата в полето `power`
- `compareByType` → сравнява по `ItemType`, използвайки числовите стойности на `enum`

Да се реализира функция:

```cpp
void reorganizeInventory(Item*& inventory, int size, ItemComparator comp);
```

Функцията трябва да:

- Сортира масива *in-place*
- Използва подадения компаратор
- Използва алгоритъм по избор (напр. *Bubble Sort*)

Да се реализира функция:

```cpp
void compactInventory(Item*& inventory, int& size);
```

Функцията трябва да:

- Премахне всички предмети с `weight > 50.0`
- Задели нов масив с точен размер
- Копира валидните елементи
- Освободи старата памет
- Актуализира указателя и размера